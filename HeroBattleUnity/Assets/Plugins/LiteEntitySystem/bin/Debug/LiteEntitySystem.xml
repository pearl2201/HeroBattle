<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LiteEntitySystem</name>
    </assembly>
    <members>
        <member name="T:LiteEntitySystem.ClientEntityManager">
            <summary>
            Client entity manager
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.ServerTick">
            <summary>
            Current interpolated server tick
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.RollBackTick">
            <summary>
            Current rollback tick (valid only in Rollback state)
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.CurrentRPCTick">
            <summary>
            Tick of currently executing rpc (check only in client RPC methods)
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.IsExecutingRPC">
            <summary>
            Is rpc currently executing
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.RawServerTick">
            <summary>
            Current state server tick
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.RawTargetServerTick">
            <summary>
            Target state server tick
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.LocalPlayer">
            <summary>
            Our local player
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.StoredCommands">
            <summary>
            Stored input commands count for prediction correction
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.LastProcessedTick">
            <summary>
            Player tick processed by server
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.LastReceivedTick">
            <summary>
            Last received player tick by server
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.ServerInputBuffer">
            <summary>
            Inputs count in server input buffer
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.ServerSendRate">
            <summary>
            Send rate of server
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.LerpBufferCount">
            <summary>
            States count in interpolation buffer
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.NetPeer">
            <summary>
            Client network peer
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ClientEntityManager.NetworkJitter">
            <summary>
            Network jitter in milliseconds
            </summary>
        </member>
        <member name="M:LiteEntitySystem.ClientEntityManager.GetPlayerController``1">
            <summary>
            Return client controller if exist
            </summary>
            <typeparam name="T">controller type</typeparam>
            <returns>controller if exist otherwise null</returns>
        </member>
        <member name="M:LiteEntitySystem.ClientEntityManager.#ctor(LiteEntitySystem.EntityTypesMap,LiteEntitySystem.InputProcessor,LiteEntitySystem.Transport.AbstractNetPeer,System.Byte,System.Byte)">
            <summary>
            Constructor
            </summary>
            <param name="typesMap">EntityTypesMap with registered entity types</param>
            <param name="inputProcessor">Input processor (you can use default InputProcessor/<T/> or derive from abstract one to make your own input serialization</param>
            <param name="netPeer">Local AbstractPeer</param>
            <param name="headerByte">Header byte that will be used for packets (to distinguish entity system packets)</param>
            <param name="framesPerSecond">Fixed framerate of game logic</param>
        </member>
        <member name="M:LiteEntitySystem.ClientEntityManager.Create``1(LiteEntitySystem.EntityTypesMap,LiteEntitySystem.Transport.AbstractNetPeer,System.Byte,System.Byte)">
            <summary>
            Simplified constructor
            </summary>
            <param name="typesMap">EntityTypesMap with registered entity types</param>
            <param name="netPeer">Local AbstractPeer</param>
            <param name="headerByte">Header byte that will be used for packets (to distinguish entity system packets)</param>
            <param name="framesPerSecond">Fixed framerate of game logic</param>
            <typeparam name="TInput">Main input packet type</typeparam>
        </member>
        <member name="M:LiteEntitySystem.ClientEntityManager.Deserialize(System.ReadOnlySpan{System.Byte})">
            Read incoming data
            <param name="inData">Incoming data including header byte</param>
            <returns>Deserialization result</returns>
        </member>
        <member name="M:LiteEntitySystem.ClientEntityManager.Update">
            <summary>
            Update method, call this every frame
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Collections.AVLTree`1.Count">
            <summary>
            Elements count
            </summary>
        </member>
        <member name="T:LiteEntitySystem.ControllerLogic">
            <summary>
            Base class for Controller entities
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ControllerLogic.IsBot">
            <summary>
            Is controller - AI controller
            </summary>
        </member>
        <member name="T:LiteEntitySystem.AiControllerLogic">
            <summary>
            Base class for AI Controller entities
            </summary>
        </member>
        <member name="T:LiteEntitySystem.AiControllerLogic`1">
            <summary>
            Base class for AI Controller entities with typed ControlledEntity field
            </summary>
        </member>
        <member name="E:LiteEntitySystem.EntityFilter`1.OnDestroyed">
            <summary>
            Called when entity is removed/destroyed
            </summary>
        </member>
        <member name="M:LiteEntitySystem.EntityFilter`1.SubscribeToConstructed(System.Action{`0},System.Boolean)">
            <summary>
            Called when entity created and synced
            <param name="onConstructed">callback</param>
            <param name="callOnExisting">call that callback on existing entities in this filter/list</param>
            </summary>
        </member>
        <member name="M:LiteEntitySystem.EntityFilter`1.UnsubscribeToConstructed(System.Action{`0})">
            <summary>
            Called when entity created and synced
            <param name="onConstructed">callback</param>
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityFlags.UpdateOnClient">
            <summary>
            Update entity on client even when entity isn't owned
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityFlags.Updateable">
            <summary>
            Update entity on server and on client if entity is owned 
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityFlags.LocalOnly">
            <summary>
            Entity is local only without sync (only on server or client no difference)
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityFlags.OnlyForOwner">
            <summary>
            Sync entity only for owner player
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityFlags.CustomSync">
            <summary>
            Handle sync details before sending to player
            </summary>
        </member>
        <member name="T:LiteEntitySystem.EntityLogic">
            <summary>
            Base class for simple (not controlled by controller) entity
            </summary>
        </member>
        <member name="P:LiteEntitySystem.EntityLogic.Childs">
            <summary>
            Child entities (can be used for transforms or as components)
            </summary>
        </member>
        <member name="M:LiteEntitySystem.EntityLogic.EnableLagCompensationForOwner">
            <summary>
            Enable lag compensation for player that owns this entity
            </summary>
        </member>
        <member name="M:LiteEntitySystem.EntityLogic.DisableLagCompensationForOwner">
            <summary>
            Disable lag compensation for player that owns this entity
            </summary>
        </member>
        <member name="M:LiteEntitySystem.EntityLogic.AddPredictedEntity``1(System.Action{``0})">
            <summary>
            Create predicted entity (like projectile) that will be replaced by server entity if prediction is successful
            </summary>
            <typeparam name="T">Entity type</typeparam>
            <param name="initMethod">Method that will be called after entity constructed</param>
            <returns>Created predicted local entity</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityLogic.SetParent(LiteEntitySystem.EntityLogic)">
            <summary>
            Set parent entity
            </summary>
            <param name="parentEntity">parent entity</param>
        </member>
        <member name="M:LiteEntitySystem.EntityLogic.GetParent``1">
            <summary>
            Get parent entity
            </summary>
            <typeparam name="T">Type of entity</typeparam>
            <returns>parent entity</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityLogic.OnLagCompensationStart">
            <summary>
            Called when lag compensation was started for this entity
            </summary>
        </member>
        <member name="M:LiteEntitySystem.EntityLogic.OnLagCompensationEnd">
            <summary>
            Called when lag compensation ended for this entity
            </summary>
        </member>
        <member name="F:LiteEntitySystem.ExecuteFlags.SendToOwner">
            <summary>Execute RPC for owner of entity</summary>
        </member>
        <member name="F:LiteEntitySystem.ExecuteFlags.SendToOther">
            <summary>Execute RPC for non owners</summary>
        </member>
        <member name="F:LiteEntitySystem.ExecuteFlags.SendToAll">
            <summary>Execute RPC for all players</summary>
        </member>
        <member name="F:LiteEntitySystem.ExecuteFlags.ExecuteOnPrediction">
            <summary>Execute RPC on client for owner of entity on prediction</summary>
        </member>
        <member name="F:LiteEntitySystem.ExecuteFlags.ExecuteOnServer">
            <summary>Execute RPC directly on server</summary>
        </member>
        <member name="F:LiteEntitySystem.ExecuteFlags.All">
            <summary>All flags, send to owner, to others, execute on prediction and on server</summary>
        </member>
        <member name="T:LiteEntitySystem.EntityManager">
            <summary>
            Base class for client and server manager
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityManager.MaxSyncedEntityCount">
            <summary>
            Maximum synchronized (without LocalOnly) entities
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityManager.InvalidEntityId">
            <summary>
            Invalid entity id
            </summary>
        </member>
        <member name="P:LiteEntitySystem.EntityManager.EntitiesCount">
            <summary>
            Total entities count (including local)
            </summary>
        </member>
        <member name="P:LiteEntitySystem.EntityManager.Tick">
            <summary>
            Current tick
            </summary>
        </member>
        <member name="P:LiteEntitySystem.EntityManager.LerpFactor">
            <summary>
            Interpolation time between logic and render
            </summary>
        </member>
        <member name="P:LiteEntitySystem.EntityManager.UpdateMode">
            <summary>
            Current update mode (can be used inside entities to separate logic for rollbacks)
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityManager.Mode">
            <summary>
            Current mode (Server or Client)
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityManager.IsServer">
            <summary>
            Is server
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityManager.IsClient">
            <summary>
            Is client
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityManager.FramesPerSecond">
            <summary>
            FPS of game logic
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityManager.DeltaTime">
            <summary>
            Fixed delta time
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityManager.DeltaTimeF">
            <summary>
            Fixed delta time (float for less precision)
            </summary>
        </member>
        <member name="F:LiteEntitySystem.EntityManager.MaxHistorySize">
            <summary>
            Size of history (in ticks) for lag compensation. Tune for your game fps 
            </summary>
        </member>
        <member name="P:LiteEntitySystem.EntityManager.PlayerId">
            <summary>
            Local player id (0 on server)
            </summary>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.Reset">
            <summary>
            Remove all entities and reset all counters and timers
            </summary>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.GetEntityById``1(LiteEntitySystem.EntitySharedReference)">
            <summary>
            Get entity by id
            </summary>
            <param name="id">Id of entity</param>
            <returns>Entity if it exists, null if id == InvalidEntityId or entity is another type or version</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.TryGetEntityById``1(LiteEntitySystem.EntitySharedReference,``0@)">
            <summary>
            Try get entity by id
            throws exception if entity is null or invalid type
            </summary>
            <param name="id">Id of entity</param>
            <param name="entity">out entity if exists otherwise null</param>
            <returns>true if it exists, false if id == InvalidEntityId or entity is another type or version</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.GetEntities``1">
            <summary>
            Get all entities with type
            </summary>
            <typeparam name="T">Entity type</typeparam>
            <returns>Entity filter that can be used in foreach</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.GetControllers``1">
            <summary>
            Get all controller entities with type
            </summary>
            <typeparam name="T">Entity type</typeparam>
            <returns>Entity filter that can be used in foreach</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.GetSingleton``1">
            <summary>
            Get existing singleton entity
            </summary>
            <typeparam name="T">Singleton entity type</typeparam>
            <returns>Singleton entity, can throw exceptions on invalid type</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.GetSingletonSafe``1">
            <summary>
            Get singleton entity
            </summary>
            <typeparam name="T">Singleton entity type</typeparam>
            <returns>Singleton entity or null if it didn't exists</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.HasSingleton``1">
            <summary>
            Is singleton exists and has correct type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.TryGetSingleton``1(``0@)">
            <summary>
            Try get singleton entity
            </summary>
            <param name="singleton">result singleton entity</param>
            <typeparam name="T">Singleton type</typeparam>
            <returns>true if entity exists</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.AddLocalEntity``1(System.Action{``0})">
            <summary>
            Add local entity that will be not synchronized
            </summary>
            <typeparam name="T">Entity type</typeparam>
            <returns>Created entity or null if entities limit is reached (65535 - <see cref="F:LiteEntitySystem.EntityManager.MaxSyncedEntityCount"/>)</returns>
        </member>
        <member name="M:LiteEntitySystem.EntityManager.Update">
            <summary>
            Main update method, updates internal fixed timer and do all other stuff
            </summary>
        </member>
        <member name="M:LiteEntitySystem.EntityTypesMap.EvaluateEntityClassDataHash">
            <summary>
            Can be used to detect that server/client has difference
            </summary>
            <returns>hash</returns>
        </member>
        <member name="T:LiteEntitySystem.EntityTypesMap`1">
            <summary>
            Entity types map that will be used for EntityManager
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:LiteEntitySystem.EntityTypesMap`1.Register``1(`0,LiteEntitySystem.EntityConstructor{``0})">
            <summary>
            Register new entity type that will be used in game
            </summary>
            <param name="id">Enum value that will describe entity class id</param>
            <param name="constructor">Constructor of entity</param>
            <typeparam name="TEntity">Type of entity</typeparam>
        </member>
        <member name="T:LiteEntitySystem.Extensions.FloatAngle">
            <summary>
            Float angle in degress with correct interpolation and overlaps
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Extensions.SyncArray`1.Value">
            <summary>
            Changes to this array will NOT sync,
            so it should be used as readonly!
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Extensions.SyncSquare`1.Value">
            <summary>
            Changes to this array will NOT sync,
            so it should be used as readonly!
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M11">
            <summary>
            Value at row 1, column 1 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M12">
            <summary>
            Value at row 1, column 2 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M13">
            <summary>
            Value at row 1, column 3 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M14">
            <summary>
            Value at row 1, column 4 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M21">
            <summary>
            Value at row 2, column 1 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M22">
            <summary>
            Value at row 2, column 2 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M23">
            <summary>
            Value at row 2, column 3 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M24">
            <summary>
            Value at row 2, column 4 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M31">
            <summary>
            Value at row 3, column 1 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M32">
            <summary>
            Value at row 3, column 2 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M33">
            <summary>
            Value at row 3, column 3 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M34">
            <summary>
            Value at row 3, column 4 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M41">
            <summary>
            Value at row 4, column 1 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M42">
            <summary>
            Value at row 4, column 2 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M43">
            <summary>
            Value at row 4, column 3 of the matrix.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Matrix4x4f.M44">
            <summary>
            Value at row 4, column 4 of the matrix.
            </summary>
        </member>
        <member name="P:LiteEntitySystem.FixedMath.Matrix4x4f.Identity">
            <summary>
            Returns the multiplicative identity matrix.
            </summary>
        </member>
        <member name="P:LiteEntitySystem.FixedMath.Matrix4x4f.IsIdentity">
            <summary>
            Returns whether the matrix is the identity matrix.
            </summary>
        </member>
        <member name="P:LiteEntitySystem.FixedMath.Matrix4x4f.Translation">
            <summary>
            Gets or sets the translation component of this matrix.
            </summary>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a Matrix4x4f from the given components.
            </summary>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateBillboard(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a spherical billboard that rotates around a specified object position.
            </summary>
            <param name="objectPosition">Position of the object the billboard will rotate around.</param>
            <param name="cameraPosition">Position of the camera.</param>
            <param name="cameraUpVector">The up vector of the camera.</param>
            <param name="cameraForwardVector">The forward vector of the camera.</param>
            <returns>The created billboard matrix</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateConstrainedBillboard(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a cylindrical billboard that rotates around a specified axis.
            </summary>
            <param name="objectPosition">Position of the object the billboard will rotate around.</param>
            <param name="cameraPosition">Position of the camera.</param>
            <param name="rotateAxis">Axis to rotate the billboard around.</param>
            <param name="cameraForwardVector">Forward vector of the camera.</param>
            <param name="objectForwardVector">Forward vector of the object.</param>
            <returns>The created billboard matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateTranslation(HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a translation matrix.
            </summary>
            <param name="position">The amount to translate in each axis.</param>
            <returns>The translation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateTranslation(System.Single,System.Single,System.Single)">
            <summary>
            Creates a translation matrix.
            </summary>
            <param name="xPosition">The amount to translate on the X-axis.</param>
            <param name="yPosition">The amount to translate on the Y-axis.</param>
            <param name="zPosition">The amount to translate on the Z-axis.</param>
            <returns>The translation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateScale(System.Single,System.Single,System.Single)">
            <summary>
            Creates a scaling matrix.
            </summary>
            <param name="xScale">Value to scale by on the X-axis.</param>
            <param name="yScale">Value to scale by on the Y-axis.</param>
            <param name="zScale">Value to scale by on the Z-axis.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateScale(System.Single,System.Single,System.Single,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a scaling matrix with a center point.
            </summary>
            <param name="xScale">Value to scale by on the X-axis.</param>
            <param name="yScale">Value to scale by on the Y-axis.</param>
            <param name="zScale">Value to scale by on the Z-axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateScale(HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a scaling matrix.
            </summary>
            <param name="scales">The vector containing the amount to scale by on each axis.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateScale(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a scaling matrix with a center point.
            </summary>
            <param name="scales">The vector containing the amount to scale by on each axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateScale(System.Single)">
            <summary>
            Creates a uniform scaling matrix that scales equally on each axis.
            </summary>
            <param name="scale">The uniform scaling factor.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateScale(System.Single,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a uniform scaling matrix that scales equally on each axis with a center point.
            </summary>
            <param name="scale">The uniform scaling factor.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The scaling matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateRotationX(System.Single)">
            <summary>
            Creates a matrix for rotating points around the X-axis.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the X-axis.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateRotationX(System.Single,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a matrix for rotating points around the X-axis, from a center point.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the X-axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateRotationY(System.Single)">
            <summary>
            Creates a matrix for rotating points around the Y-axis.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the Y-axis.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateRotationY(System.Single,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a matrix for rotating points around the Y-axis, from a center point.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the Y-axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateRotationZ(System.Single)">
            <summary>
            Creates a matrix for rotating points around the Z-axis.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the Z-axis.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateRotationZ(System.Single,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a matrix for rotating points around the Z-axis, from a center point.
            </summary>
            <param name="radians">The amount, in radians, by which to rotate around the Z-axis.</param>
            <param name="centerPoint">The center point.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateFromAxisAngle(HeroBattle.FixedMath.Vector3f,System.Single)">
            <summary>
            Creates a matrix that rotates around an arbitrary vector.
            </summary>
            <param name="axis">The axis to rotate around.</param>
            <param name="angle">The angle to rotate around the given axis, in radians.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreatePerspectiveFieldOfView(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a perspective projection matrix based on a field of view, aspect ratio, and near and far view plane distances. 
            </summary>
            <param name="fieldOfView">Field of view in the y direction, in radians.</param>
            <param name="aspectRatio">Aspect ratio, defined as view space width divided by height.</param>
            <param name="nearPlaneDistance">Distance to the near view plane.</param>
            <param name="farPlaneDistance">Distance to the far view plane.</param>
            <returns>The perspective projection matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreatePerspective(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a perspective projection matrix from the given view volume dimensions.
            </summary>
            <param name="width">Width of the view volume at the near view plane.</param>
            <param name="height">Height of the view volume at the near view plane.</param>
            <param name="nearPlaneDistance">Distance to the near view plane.</param>
            <param name="farPlaneDistance">Distance to the far view plane.</param>
            <returns>The perspective projection matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreatePerspectiveOffCenter(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a customized, perspective projection matrix.
            </summary>
            <param name="left">Minimum x-value of the view volume at the near view plane.</param>
            <param name="right">Maximum x-value of the view volume at the near view plane.</param>
            <param name="bottom">Minimum y-value of the view volume at the near view plane.</param>
            <param name="top">Maximum y-value of the view volume at the near view plane.</param>
            <param name="nearPlaneDistance">Distance to the near view plane.</param>
            <param name="farPlaneDistance">Distance to of the far view plane.</param>
            <returns>The perspective projection matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateOrthographic(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates an orthographic perspective matrix from the given view volume dimensions.
            </summary>
            <param name="width">Width of the view volume.</param>
            <param name="height">Height of the view volume.</param>
            <param name="zNearPlane">Minimum Z-value of the view volume.</param>
            <param name="zFarPlane">Maximum Z-value of the view volume.</param>
            <returns>The orthographic projection matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateOrthographicOffCenter(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Builds a customized, orthographic projection matrix.
            </summary>
            <param name="left">Minimum X-value of the view volume.</param>
            <param name="right">Maximum X-value of the view volume.</param>
            <param name="bottom">Minimum Y-value of the view volume.</param>
            <param name="top">Maximum Y-value of the view volume.</param>
            <param name="zNearPlane">Minimum Z-value of the view volume.</param>
            <param name="zFarPlane">Maximum Z-value of the view volume.</param>
            <returns>The orthographic projection matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateLookAt(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a view matrix.
            </summary>
            <param name="cameraPosition">The position of the camera.</param>
            <param name="cameraTarget">The target towards which the camera is pointing.</param>
            <param name="cameraUpVector">The direction that is "up" from the camera's point of view.</param>
            <returns>The view matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateWorld(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Creates a world matrix with the specified parameters.
            </summary>
            <param name="position">The position of the object; used in translation operations.</param>
            <param name="forward">Forward direction of the object.</param>
            <param name="up">Upward direction of the object; usually [0, 1, 0].</param>
            <returns>The world matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateFromQuaternion(LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Creates a rotation matrix from the given Quaternion rotation value.
            </summary>
            <param name="quaternion">The source Quaternion.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.CreateFromYawPitchRoll(System.Single,System.Single,System.Single)">
            <summary>
            Creates a rotation matrix from the specified yaw, pitch, and roll.
            </summary>
            <param name="yaw">Angle of rotation, in radians, around the Y-axis.</param>
            <param name="pitch">Angle of rotation, in radians, around the X-axis.</param>
            <param name="roll">Angle of rotation, in radians, around the Z-axis.</param>
            <returns>The rotation matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.GetDeterminant">
            <summary>
            Calculates the determinant of the matrix.
            </summary>
            <returns>The determinant of the matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Invert(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f@)">
            <summary>
            Attempts to calculate the inverse of the given matrix. If successful, result will contain the inverted matrix.
            </summary>
            <param name="matrix">The source matrix to invert.</param>
            <param name="result">If successful, contains the inverted matrix.</param>
            <returns>True if the source matrix could be inverted; False otherwise.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Decompose(LiteEntitySystem.FixedMath.Matrix4x4f,HeroBattle.FixedMath.Vector3f@,LiteEntitySystem.FixedMath.Quaternion@,HeroBattle.FixedMath.Vector3f@)">
            <summary>
            Attempts to extract the scale, translation, and rotation components from the given scale/rotation/translation matrix.
            If successful, the out parameters will contained the extracted values.
            </summary>
            <param name="matrix">The source matrix.</param>
            <param name="scale">The scaling component of the transformation matrix.</param>
            <param name="rotation">The rotation component of the transformation matrix.</param>
            <param name="translation">The translation component of the transformation matrix</param>
            <returns>True if the source matrix was successfully decomposed; False otherwise.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Transform(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Transforms the given matrix by applying the given Quaternion rotation.
            </summary>
            <param name="value">The source matrix to transform.</param>
            <param name="rotation">The rotation to apply.</param>
            <returns>The transformed matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Transpose(LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Transposes the rows and columns of a matrix.
            </summary>
            <param name="matrix">The source matrix.</param>
            <returns>The transposed matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Lerp(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f,System.Single)">
            <summary>
            Linearly interpolates between the corresponding values of two matrices.
            </summary>
            <param name="matrix1">The first source matrix.</param>
            <param name="matrix2">The second source matrix.</param>
            <param name="amount">The relative weight of the second source matrix.</param>
            <returns>The interpolated matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Negate(LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Returns a new matrix with the negated elements of the given matrix.
            </summary>
            <param name="value">The source matrix.</param>
            <returns>The negated matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Add(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Adds two matrices together.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The resulting matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Subtract(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Subtracts the second matrix from the first.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The result of the subtraction.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Multiply(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Multiplies a matrix by another matrix.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Multiply(LiteEntitySystem.FixedMath.Matrix4x4f,System.Single)">
            <summary>
            Multiplies a matrix by a scalar value.
            </summary>
            <param name="value1">The source matrix.</param>
            <param name="value2">The scaling factor.</param>
            <returns>The scaled matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.op_UnaryNegation(LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Returns a new matrix with the negated elements of the given matrix.
            </summary>
            <param name="value">The source matrix.</param>
            <returns>The negated matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.op_Addition(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Adds two matrices together.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The resulting matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.op_Subtraction(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Subtracts the second matrix from the first.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The result of the subtraction.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.op_Multiply(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Multiplies a matrix by another matrix.
            </summary>
            <param name="value1">The first source matrix.</param>
            <param name="value2">The second source matrix.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.op_Multiply(LiteEntitySystem.FixedMath.Matrix4x4f,System.Single)">
            <summary>
            Multiplies a matrix by a scalar value.
            </summary>
            <param name="value1">The source matrix.</param>
            <param name="value2">The scaling factor.</param>
            <returns>The scaled matrix.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.op_Equality(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Returns a boolean indicating whether the given two matrices are equal.
            </summary>
            <param name="value1">The first matrix to compare.</param>
            <param name="value2">The second matrix to compare.</param>
            <returns>True if the given matrices are equal; False otherwise.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.op_Inequality(LiteEntitySystem.FixedMath.Matrix4x4f,LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Returns a boolean indicating whether the given two matrices are not equal.
            </summary>
            <param name="value1">The first matrix to compare.</param>
            <param name="value2">The second matrix to compare.</param>
            <returns>True if the given matrices are not equal; False if they are equal.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Equals(LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Returns a boolean indicating whether this matrix instance is equal to the other given matrix.
            </summary>
            <param name="other">The matrix to compare this instance to.</param>
            <returns>True if the matrices are equal; False otherwise.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.Equals(System.Object)">
            <summary>
            Returns a boolean indicating whether the given Object is equal to this matrix instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this matrix; False otherwise.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.ToString">
            <summary>
            Returns a String representing this matrix instance.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Matrix4x4f.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Quaternion.X">
            <summary>
            Specifies the X-value of the vector component of the Quaternion.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Quaternion.Y">
            <summary>
            Specifies the Y-value of the vector component of the Quaternion.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Quaternion.Z">
            <summary>
            Specifies the Z-value of the vector component of the Quaternion.
            </summary>
        </member>
        <member name="F:LiteEntitySystem.FixedMath.Quaternion.W">
            <summary>
            Specifies the rotation component of the Quaternion.
            </summary>
        </member>
        <member name="P:LiteEntitySystem.FixedMath.Quaternion.Identity">
            <summary>
            Returns a Quaternion representing no rotation. 
            </summary>
        </member>
        <member name="P:LiteEntitySystem.FixedMath.Quaternion.IsIdentity">
            <summary>
            Returns whether the Quaternion is the identity Quaternion.
            </summary>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a Quaternion from the given components.
            </summary>
            <param name="x">The X component of the Quaternion.</param>
            <param name="y">The Y component of the Quaternion.</param>
            <param name="z">The Z component of the Quaternion.</param>
            <param name="w">The W component of the Quaternion.</param>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.#ctor(HeroBattle.FixedMath.Vector3f,System.Single)">
            <summary>
            Constructs a Quaternion from the given vector and rotation parts.
            </summary>
            <param name="vectorPart">The vector part of the Quaternion.</param>
            <param name="scalarPart">The rotation part of the Quaternion.</param>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Length">
            <summary>
            Calculates the length of the Quaternion.
            </summary>
            <returns>The computed length of the Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.LengthSquared">
            <summary>
            Calculates the length squared of the Quaternion. This operation is cheaper than Length().
            </summary>
            <returns>The length squared of the Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Normalize(LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Divides each component of the Quaternion by the length of the Quaternion.
            </summary>
            <param name="value">The source Quaternion.</param>
            <returns>The normalized Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Conjugate(LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Creates the conjugate of a specified Quaternion.
            </summary>
            <param name="value">The Quaternion of which to return the conjugate.</param>
            <returns>A new Quaternion that is the conjugate of the specified one.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Inverse(LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Returns the inverse of a Quaternion.
            </summary>
            <param name="value">The source Quaternion.</param>
            <returns>The inverted Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.CreateFromAxisAngle(HeroBattle.FixedMath.Vector3f,System.Single)">
            <summary>
            Creates a Quaternion from a vector and an angle to rotate about the vector.
            </summary>
            <param name="axis">The vector to rotate around.</param>
            <param name="angle">The angle, in radians, to rotate around the vector.</param>
            <returns>The created Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.CreateFromYawPitchRoll(System.Single,System.Single,System.Single)">
            <summary>
            Creates a new Quaternion from the given yaw, pitch, and roll, in radians.
            </summary>
            <param name="yaw">The yaw angle, in radians, around the Y-axis.</param>
            <param name="pitch">The pitch angle, in radians, around the X-axis.</param>
            <param name="roll">The roll angle, in radians, around the Z-axis.</param>
            <returns></returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.CreateFromRotationMatrix(LiteEntitySystem.FixedMath.Matrix4x4f)">
            <summary>
            Creates a Quaternion from the given rotation matrix.
            </summary>
            <param name="matrix">The rotation matrix.</param>
            <returns>The created Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Dot(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Calculates the dot product of two Quaternions.
            </summary>
            <param name="quaternion1">The first source Quaternion.</param>
            <param name="quaternion2">The second source Quaternion.</param>
            <returns>The dot product of the Quaternions.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Slerp(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion,System.Single)">
            <summary>
            Interpolates between two quaternions, using spherical linear interpolation.
            </summary>
            <param name="quaternion1">The first source Quaternion.</param>
            <param name="quaternion2">The second source Quaternion.</param>
            <param name="amount">The relative weight of the second source Quaternion in the interpolation.</param>
            <returns>The interpolated Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Lerp(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion,System.Single)">
            <summary>
             Linearly interpolates between two quaternions.
            </summary>
            <param name="quaternion1">The first source Quaternion.</param>
            <param name="quaternion2">The second source Quaternion.</param>
            <param name="amount">The relative weight of the second source Quaternion in the interpolation.</param>
            <returns>The interpolated Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Concatenate(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Concatenates two Quaternions; the result represents the value1 rotation followed by the value2 rotation.
            </summary>
            <param name="value1">The first Quaternion rotation in the series.</param>
            <param name="value2">The second Quaternion rotation in the series.</param>
            <returns>A new Quaternion representing the concatenation of the value1 rotation followed by the value2 rotation.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Negate(LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Flips the sign of each component of the quaternion.
            </summary>
            <param name="value">The source Quaternion.</param>
            <returns>The negated Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Add(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Adds two Quaternions element-by-element.
            </summary>
            <param name="value1">The first source Quaternion.</param>
            <param name="value2">The second source Quaternion.</param>
            <returns>The result of adding the Quaternions.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Subtract(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Subtracts one Quaternion from another.
            </summary>
            <param name="value1">The first source Quaternion.</param>
            <param name="value2">The second Quaternion, to be subtracted from the first.</param>
            <returns>The result of the subtraction.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Multiply(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Multiplies two Quaternions together.
            </summary>
            <param name="value1">The Quaternion on the left side of the multiplication.</param>
            <param name="value2">The Quaternion on the right side of the multiplication.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Multiply(LiteEntitySystem.FixedMath.Quaternion,System.Single)">
            <summary>
            Multiplies a Quaternion by a scalar value.
            </summary>
            <param name="value1">The source Quaternion.</param>
            <param name="value2">The scalar value.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Divide(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Divides a Quaternion by another Quaternion.
            </summary>
            <param name="value1">The source Quaternion.</param>
            <param name="value2">The divisor.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.op_UnaryNegation(LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Flips the sign of each component of the quaternion.
            </summary>
            <param name="value">The source Quaternion.</param>
            <returns>The negated Quaternion.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.op_Addition(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Adds two Quaternions element-by-element.
            </summary>
            <param name="value1">The first source Quaternion.</param>
            <param name="value2">The second source Quaternion.</param>
            <returns>The result of adding the Quaternions.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.op_Subtraction(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Subtracts one Quaternion from another.
            </summary>
            <param name="value1">The first source Quaternion.</param>
            <param name="value2">The second Quaternion, to be subtracted from the first.</param>
            <returns>The result of the subtraction.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.op_Multiply(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Multiplies two Quaternions together.
            </summary>
            <param name="value1">The Quaternion on the left side of the multiplication.</param>
            <param name="value2">The Quaternion on the right side of the multiplication.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.op_Multiply(LiteEntitySystem.FixedMath.Quaternion,System.Single)">
            <summary>
            Multiplies a Quaternion by a scalar value.
            </summary>
            <param name="value1">The source Quaternion.</param>
            <param name="value2">The scalar value.</param>
            <returns>The result of the multiplication.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.op_Division(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Divides a Quaternion by another Quaternion.
            </summary>
            <param name="value1">The source Quaternion.</param>
            <param name="value2">The divisor.</param>
            <returns>The result of the division.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.op_Equality(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Returns a boolean indicating whether the two given Quaternions are equal.
            </summary>
            <param name="value1">The first Quaternion to compare.</param>
            <param name="value2">The second Quaternion to compare.</param>
            <returns>True if the Quaternions are equal; False otherwise.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.op_Inequality(LiteEntitySystem.FixedMath.Quaternion,LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Returns a boolean indicating whether the two given Quaternions are not equal.
            </summary>
            <param name="value1">The first Quaternion to compare.</param>
            <param name="value2">The second Quaternion to compare.</param>
            <returns>True if the Quaternions are not equal; False if they are equal.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Equals(LiteEntitySystem.FixedMath.Quaternion)">
            <summary>
            Returns a boolean indicating whether the given Quaternion is equal to this Quaternion instance.
            </summary>
            <param name="other">The Quaternion to compare this instance to.</param>
            <returns>True if the other Quaternion is equal to this instance; False otherwise.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.Equals(System.Object)">
            <summary>
            Returns a boolean indicating whether the given Object is equal to this Quaternion instance.
            </summary>
            <param name="obj">The Object to compare against.</param>
            <returns>True if the Object is equal to this Quaternion; False otherwise.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.ToString">
            <summary>
            Returns a String representing this Quaternion instance.
            </summary>
            <returns>The string representation.</returns>
        </member>
        <member name="M:LiteEntitySystem.FixedMath.Quaternion.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="T:LiteEntitySystem.HumanControllerLogic`1">
            <summary>
            Base class for human Controller entities
            </summary>
        </member>
        <member name="M:LiteEntitySystem.HumanControllerLogic`1.ReadInput(`0@)">
            <summary>
            Called on client and server to read generated from <see cref="M:LiteEntitySystem.HumanControllerLogic`1.GenerateInput(`0@)"/> input
            </summary>
            <param name="input">user defined input structure</param>
        </member>
        <member name="M:LiteEntitySystem.HumanControllerLogic`1.GenerateInput(`0@)">
            <summary>
            Called on client to generate input
            </summary>
        </member>
        <member name="T:LiteEntitySystem.HumanControllerLogic`2">
            <summary>
            Base class for human Controller entities with typed ControlledEntity field
            </summary>
        </member>
        <member name="F:LiteEntitySystem.Internal.InternalEntity.ClassId">
            <summary>
            Entity class id
            </summary>
        </member>
        <member name="F:LiteEntitySystem.Internal.InternalEntity.Id">
            <summary>
            Entity instance id
            </summary>
        </member>
        <member name="F:LiteEntitySystem.Internal.InternalEntity.CreationTick">
            <summary>
            Entity creation tick number that can be more than ushort
            </summary>
        </member>
        <member name="F:LiteEntitySystem.Internal.InternalEntity.EntityManager">
            <summary>
            Entity manager
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.IsServer">
            <summary>
            Is entity on server
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.IsClient">
            <summary>
            Is entity on server
            </summary>
        </member>
        <member name="F:LiteEntitySystem.Internal.InternalEntity.Version">
            <summary>
            Entity version (for id reuse)
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.IsDestroyed">
            <summary>
            Is entity is destroyed
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.IsLocalControlled">
            <summary>
            Is entity local controlled
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.IsRemoteControlled">
            <summary>
            Is entity remote controlled
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.IsServerControlled">
            <summary>
            Is entity is controlled by server
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.ClientManager">
            <summary>
            ClientEntityManager that available only on client. Will throw exception if called on server
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.ServerManager">
            <summary>
            ServerEntityManager that available only on server. Will throw exception if called on client
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.OwnerId">
            <summary>
            Owner player id
            ServerPlayerId - 0
            Singletons always controlled by server
            </summary>
        </member>
        <member name="P:LiteEntitySystem.Internal.InternalEntity.IsLocal">
            <summary>
            Is locally created entity
            </summary>
        </member>
        <member name="M:LiteEntitySystem.Internal.InternalEntity.Destroy">
            <summary>
            Destroy entity
            </summary>
        </member>
        <member name="M:LiteEntitySystem.Internal.InternalEntity.OnDestroy">
            <summary>
            Event called on entity destroy
            </summary>
        </member>
        <member name="M:LiteEntitySystem.Internal.InternalEntity.Update">
            <summary>
            Fixed update. Called if entity has attribute <see cref="T:LiteEntitySystem.EntityFlagsAttribute"/> and flag Updateable
            </summary>
        </member>
        <member name="M:LiteEntitySystem.Internal.InternalEntity.OnRollback">
            <summary>
            Called at rollback begin after all values reset to first frame in rollback queue.
            </summary>
        </member>
        <member name="M:LiteEntitySystem.Internal.InternalEntity.VisualUpdate">
            <summary>
            Called only on <see cref="M:LiteEntitySystem.ClientEntityManager.Update"/> and if entity has attribute <see cref="T:LiteEntitySystem.EntityFlagsAttribute"/> and flag Updateable
            </summary>
        </member>
        <member name="M:LiteEntitySystem.Internal.InternalEntity.OnConstructed">
            <summary>
            Called when entity constructed
            </summary>
        </member>
        <member name="M:LiteEntitySystem.Internal.InternalEntity.RegisterRPC(LiteEntitySystem.RPCRegistrator@)">
            <summary>
            Method for registering RPCs and OnChange notifications
            </summary>
            <param name="r"></param>
        </member>
        <member name="T:LiteEntitySystem.ILogger">
            <summary>
            Logger implementation for different situations (client/server/different engine)
            </summary>
        </member>
        <member name="T:LiteEntitySystem.PawnLogic">
            <summary>
            Base class for entites that can be controlled by Controller
            </summary>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.BindOnChange``2(``1,LiteEntitySystem.SyncVar{``0}@,System.Action{``0})">
            <summary>
            Bind notification of SyncVar changes to action (OnSync will be called after RPCs and OnConstructs)
            </summary>
            <param name="self">Target entity for binding</param>
            <param name="syncVar">Variable to bind</param>
            <param name="onChangedAction">Action that will be called when variable changes by sync</param>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.BindOnChange``2(``1,LiteEntitySystem.SyncVar{``0}@,System.Action{``0},LiteEntitySystem.Internal.OnSyncExecutionOrder)">
            <summary>
            Bind notification of SyncVar changes to action
            </summary>
            <param name="self">Target entity for binding</param>
            <param name="syncVar">Variable to bind</param>
            <param name="onChangedAction">Action that will be called when variable changes by sync</param>
            <param name="executionOrder">order of execution</param>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.CreateRPCAction``1(``0,System.Action,LiteEntitySystem.RemoteCall@,LiteEntitySystem.ExecuteFlags)">
            <summary>
            Creates cached rpc action
            </summary>
            <param name="self">Target entity with RPC</param>
            <param name="methodToCall">RPC method to call</param>
            <param name="remoteCallHandle">output handle that should be used to call rpc</param>
            <param name="flags">RPC execution flags</param>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.CreateRPCAction``2(``0,System.Action{``1},LiteEntitySystem.RemoteCall{``1}@,LiteEntitySystem.ExecuteFlags)">
            <summary>
            Creates cached rpc action with valueType argument
            </summary>
            <param name="self">Target entity with RPC</param>
            <param name="methodToCall">RPC method to call</param>
            <param name="remoteCallHandle">output handle that should be used to call rpc</param>
            <param name="flags">RPC execution flags</param>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.CreateRPCAction``2(``0,LiteEntitySystem.SpanAction{``1},LiteEntitySystem.RemoteCallSpan{``1}@,LiteEntitySystem.ExecuteFlags)">
            <summary>
            Creates cached rpc action with Span argument
            </summary>
            <param name="self">Target entity with RPC</param>
            <param name="methodToCall">RPC method to call</param>
            <param name="remoteCallHandle">output handle that should be used to call rpc</param>
            <param name="flags">RPC execution flags</param>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.CreateRPCAction``2(``0,System.Action{``1},LiteEntitySystem.RemoteCallSerializable{``1}@,LiteEntitySystem.ExecuteFlags)">
            <summary>
            Creates cached rpc action with ISpanSerializable argument
            </summary>
            <param name="self">Target entity with RPC</param>
            <param name="methodToCall">RPC method to call</param>
            <param name="remoteCallHandle">output handle that should be used to call rpc</param>
            <param name="flags">RPC execution flags</param>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.CreateRPCAction``1(System.Action{``0},LiteEntitySystem.RemoteCall@,LiteEntitySystem.ExecuteFlags)">
            <summary>
            Creates cached rpc action
            </summary>
            <param name="methodToCall">RPC method to call</param>
            <param name="remoteCallHandle">output handle that should be used to call rpc</param>
            <param name="flags">RPC execution flags</param>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.CreateRPCAction``2(System.Action{``0,``1},LiteEntitySystem.RemoteCall{``1}@,LiteEntitySystem.ExecuteFlags)">
            <summary>
            Creates cached rpc action with valueType argument
            </summary>
            <param name="methodToCall">RPC method to call</param>
            <param name="remoteCallHandle">output handle that should be used to call rpc</param>
            <param name="flags">RPC execution flags</param>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.CreateRPCAction``2(LiteEntitySystem.SpanAction{``0,``1},LiteEntitySystem.RemoteCallSpan{``1}@,LiteEntitySystem.ExecuteFlags)">
            <summary>
            Creates cached rpc action with Span argument
            </summary>
            <param name="methodToCall">RPC method to call</param>
            <param name="remoteCallHandle">output handle that should be used to call rpc</param>
            <param name="flags">RPC execution flags</param>
        </member>
        <member name="M:LiteEntitySystem.RPCRegistrator.CreateRPCAction``2(System.Action{``0,``1},LiteEntitySystem.RemoteCallSerializable{``1}@,LiteEntitySystem.ExecuteFlags)">
            <summary>
            Creates cached rpc action with ISpanSerializable argument
            </summary>
            <param name="methodToCall">RPC method to call</param>
            <param name="remoteCallHandle">output handle that should be used to call rpc</param>
            <param name="flags">RPC execution flags</param>
        </member>
        <member name="T:LiteEntitySystem.ServerEntityManager">
            <summary>
            Server entity manager
            </summary>
        </member>
        <member name="P:LiteEntitySystem.ServerEntityManager.PlayersCount">
            <summary>
            Network players count
            </summary>
        </member>
        <member name="F:LiteEntitySystem.ServerEntityManager.SendRate">
            <summary>
            Rate at which server will make and send packets
            </summary>
        </member>
        <member name="F:LiteEntitySystem.ServerEntityManager.SafeEntityUpdate">
            <summary>
            Add try catch to entity updates
            </summary>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.#ctor(LiteEntitySystem.EntityTypesMap,LiteEntitySystem.InputProcessor,System.Byte,System.Byte,LiteEntitySystem.ServerSendRate)">
            <summary>
            Constructor
            </summary>
            <param name="typesMap">EntityTypesMap with registered entity types</param>
            <param name="inputProcessor">Input processor (you can use default InputProcessor/<T/> or derive from abstract one to make your own input serialization</param>
            <param name="packetHeader">Header byte that will be used for packets (to distinguish entity system packets)</param>
            <param name="framesPerSecond">Fixed framerate of game logic</param>
            <param name="sendRate">Send rate of server (depends on fps)</param>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.Create``1(LiteEntitySystem.EntityTypesMap,System.Byte,System.Byte,LiteEntitySystem.ServerSendRate)">
            <summary>
            Simplified constructor
            </summary>
            <param name="typesMap">EntityTypesMap with registered entity types</param>
            <param name="packetHeader">Header byte that will be used for packets (to distinguish entity system packets)</param>
            <param name="framesPerSecond">Fixed framerate of game logic</param>
            <param name="sendRate">Send rate of server (depends on fps)</param>
            <typeparam name="TInput">Main input packet type</typeparam>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.AddPlayer(LiteEntitySystem.Transport.AbstractNetPeer)">
            <summary>
            Create and add new player
            </summary>
            <param name="peer">AbstractPeer to use</param>
            <returns>Newly created player, null if players count is maximum</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.ReconnectPlayer(LiteEntitySystem.Transport.AbstractNetPeer,System.Byte)">
            <summary>
            Reconnect player
            </summary>
            <param name="peer">AbstractPeer to use</param>
            <param name="playerId">old player Id</param>
            <returns>Previous existed player</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.GetPlayer(System.Byte)">
            <summary>
            Get player by owner id
            </summary>
            <param name="ownerId">id of player owner (Entity.OwnerId)</param>
            <returns></returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.RemovePlayer(LiteEntitySystem.Transport.AbstractNetPeer)">
            <summary>
            Remove player using NetPeer.Tag (is you assigned it or used <see cref="M:LiteEntitySystem.ServerEntityManager.AddPlayer(LiteEntitySystem.Transport.AbstractNetPeer)"/> with assignToTag)
            </summary>
            <param name="player">player to remove</param>
            <returns>true if player removed successfully, false if player not found</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.RemovePlayer(LiteEntitySystem.NetPlayer)">
            <summary>
            Remove player and it's owned entities
            </summary>
            <param name="player">player to remove</param>
            <returns>true if player removed successfully, false if player not found</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.GetPlayerController(LiteEntitySystem.Transport.AbstractNetPeer)">
            <summary>
            Returns controller owned by the player
            </summary>
            <param name="player">player</param>
            <returns>Instance if found, null if not</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.GetPlayerController(System.Byte)">
            <summary>
            Returns controller owned by the player
            </summary>
            <param name="playerId">player</param>
            <returns>Instance if found, null if not</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.GetPlayerController(LiteEntitySystem.NetPlayer)">
            <summary>
            Returns controller owned by the player
            </summary>
            <param name="player">player to remove</param>
            <returns>Instance if found, null if not</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.AddController``1(LiteEntitySystem.NetPlayer,System.Action{``0})">
            <summary>
            Add new player controller entity
            </summary>
            <param name="owner">Player that owns this controller</param>
            <param name="initMethod">Method that will be called after entity construction</param>
            <typeparam name="T">Entity type</typeparam>
            <returns>Created entity or null in case of limit</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.AddController``1(LiteEntitySystem.NetPlayer,LiteEntitySystem.PawnLogic,System.Action{``0})">
            <summary>
            Add new player controller entity and start controlling entityToControl
            </summary>
            <param name="owner">Player that owns this controller</param>
            <param name="entityToControl">pawn that will be controlled</param>
            <param name="initMethod">Method that will be called after entity construction</param>
            <typeparam name="T">Entity type</typeparam>
            <returns>Created entity or null in case of limit</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.AddAIController``1(System.Action{``0})">
            <summary>
            Add new AI controller entity
            </summary>
            <param name="initMethod">Method that will be called after entity construction</param>
            <typeparam name="T">Entity type</typeparam>
            <returns>Created entity or null in case of limit</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.AddSignleton``1(System.Action{``0})">
            <summary>
            Add new entity
            </summary>
            <param name="initMethod">Method that will be called after entity construction</param>
            <typeparam name="T">Entity type</typeparam>
            <returns>Created entity or null in case of limit</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.AddEntity``1(System.Action{``0})">
            <summary>
            Add new entity
            </summary>
            <param name="initMethod">Method that will be called after entity construction</param>
            <typeparam name="T">Entity type</typeparam>
            <returns>Created entity or null in case of limit</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.AddEntity``1(LiteEntitySystem.EntityLogic,System.Action{``0})">
            <summary>
            Add new entity and set parent entity
            </summary>
            <param name="parent">Parent entity</param>
            <param name="initMethod">Method that will be called after entity construction</param>
            <typeparam name="T">Entity type</typeparam>
            <returns>Created entity or null in case of limit</returns>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.Deserialize(LiteEntitySystem.Transport.AbstractNetPeer,System.ReadOnlySpan{System.Byte})">
            <summary>
            Read data for player linked to AbstractNetPeer
            </summary>
            <param name="peer">Player that sent input</param>
            <param name="inData">incoming data with header</param>
        </member>
        <member name="M:LiteEntitySystem.ServerEntityManager.Deserialize(LiteEntitySystem.NetPlayer,System.ReadOnlySpan{System.Byte})">
            <summary>
            Read data from NetPlayer
            </summary>
            <param name="player">Player that sent input</param>
            <param name="inData">incoming data with header</param>
        </member>
        <member name="T:LiteEntitySystem.SingletonEntityLogic">
            <summary>
            Base class for singletons entity that can exists in only one instance
            </summary>
        </member>
        <member name="M:LiteEntitySystem.SpanReader.GetStringArray(System.Int32)">
            <summary>
            Note that "maxStringLength" only limits the number of characters in a string, not its size in bytes.
            Strings that exceed this parameter are returned as empty
            </summary>
        </member>
        <member name="M:LiteEntitySystem.SpanReader.GetString(System.Int32)">
            <summary>
            Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
            </summary>
            <returns>"string.Empty" if value > "maxLength"</returns>
        </member>
        <member name="M:LiteEntitySystem.SpanReader.PeekString(System.Int32)">
            <summary>
            Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
            </summary>
        </member>
        <member name="M:LiteEntitySystem.SpanWriter.Put(System.String,System.Int32)">
            <summary>
            Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
            </summary>
        </member>
        <member name="P:LiteEntitySystem.SyncableField.IsClient">
            <summary>
            Is syncableField on client
            </summary>
        </member>
        <member name="P:LiteEntitySystem.SyncableField.IsServer">
            <summary>
            Is syncableField on server
            </summary>
        </member>
        <member name="T:FixMath.NET.Fix64">
            <summary>
            Represents a Q31.32 fixed-point number.
            </summary>
        </member>
        <member name="F:FixMath.NET.Fix64.Pi">
            <summary>
            The value of Pi
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Sign(FixMath.NET.Fix64)">
            <summary>
            Returns a number indicating the sign of a Fix64 number.
            Returns 1 if the value is positive, 0 if is 0, and -1 if it is negative.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Abs(FixMath.NET.Fix64)">
            <summary>
            Returns the absolute value of a Fix64 number.
            Note: Abs(Fix64.MinValue) == Fix64.MaxValue.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.FastAbs(FixMath.NET.Fix64)">
            <summary>
            Returns the absolute value of a Fix64 number.
            FastAbs(Fix64.MinValue) is undefined.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Floor(FixMath.NET.Fix64)">
            <summary>
            Returns the largest integer less than or equal to the specified number.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Ceiling(FixMath.NET.Fix64)">
            <summary>
            Returns the smallest integral value that is greater than or equal to the specified number.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Round(FixMath.NET.Fix64)">
            <summary>
            Rounds a value to the nearest integral value.
            If the value is halfway between an even and an uneven value, returns the even value.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.op_Addition(FixMath.NET.Fix64,FixMath.NET.Fix64)">
            <summary>
            Adds x and y. Performs saturating addition, i.e. in case of overflow, 
            rounds to MinValue or MaxValue depending on sign of operands.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.FastAdd(FixMath.NET.Fix64,FixMath.NET.Fix64)">
            <summary>
            Adds x and y witout performing overflow checking. Should be inlined by the CLR.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.op_Subtraction(FixMath.NET.Fix64,FixMath.NET.Fix64)">
            <summary>
            Subtracts y from x. Performs saturating substraction, i.e. in case of overflow, 
            rounds to MinValue or MaxValue depending on sign of operands.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.FastSub(FixMath.NET.Fix64,FixMath.NET.Fix64)">
            <summary>
            Subtracts y from x witout performing overflow checking. Should be inlined by the CLR.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.FastMul(FixMath.NET.Fix64,FixMath.NET.Fix64)">
            <summary>
            Performs multiplication without checking for overflow.
            Useful for performance-critical code where the values are guaranteed not to cause overflow
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.FastMod(FixMath.NET.Fix64,FixMath.NET.Fix64)">
            <summary>
            Performs modulo as fast as possible; throws if x == MinValue and y == -1.
            Use the operator (%) for a more reliable but slower modulo.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Pow2(FixMath.NET.Fix64)">
            <summary>
            Returns 2 raised to the specified power.
            Provides at least 6 decimals of accuracy.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Log2(FixMath.NET.Fix64)">
            <summary>
            Returns the base-2 logarithm of a specified number.
            Provides at least 9 decimals of accuracy.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The argument was non-positive
            </exception>
        </member>
        <member name="M:FixMath.NET.Fix64.Ln(FixMath.NET.Fix64)">
            <summary>
            Returns the natural logarithm of a specified number.
            Provides at least 7 decimals of accuracy.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The argument was non-positive
            </exception>
        </member>
        <member name="M:FixMath.NET.Fix64.Pow(FixMath.NET.Fix64,FixMath.NET.Fix64)">
            <summary>
            Returns a specified number raised to the specified power.
            Provides about 5 digits of accuracy for the result.
            </summary>
            <exception cref="T:System.DivideByZeroException">
            The base was zero, with a negative exponent
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The base was negative, with a non-zero exponent
            </exception>
        </member>
        <member name="M:FixMath.NET.Fix64.Sqrt(FixMath.NET.Fix64)">
            <summary>
            Returns the square root of a specified number.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The argument was negative.
            </exception>
        </member>
        <member name="M:FixMath.NET.Fix64.Sin(FixMath.NET.Fix64)">
            <summary>
            Returns the Sine of x.
            The relative error is less than 1E-10 for x in [-2PI, 2PI], and less than 1E-7 in the worst case.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.FastSin(FixMath.NET.Fix64)">
            <summary>
            Returns a rough approximation of the Sine of x.
            This is at least 3 times faster than Sin() on x86 and slightly faster than Math.Sin(),
            however its accuracy is limited to 4-5 decimals, for small enough values of x.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Cos(FixMath.NET.Fix64)">
            <summary>
            Returns the cosine of x.
            The relative error is less than 1E-10 for x in [-2PI, 2PI], and less than 1E-7 in the worst case.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.FastCos(FixMath.NET.Fix64)">
            <summary>
            Returns a rough approximation of the cosine of x.
            See FastSin for more details.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Tan(FixMath.NET.Fix64)">
            <summary>
            Returns the tangent of x.
            </summary>
            <remarks>
            This function is not well-tested. It may be wildly inaccurate.
            </remarks>
        </member>
        <member name="M:FixMath.NET.Fix64.Acos(FixMath.NET.Fix64)">
            <summary>
            Returns the arccos of of the specified number, calculated using Atan and Sqrt
            This function has at least 7 decimals of accuracy.
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.Atan(FixMath.NET.Fix64)">
            <summary>
            Returns the arctan of of the specified number, calculated using Euler series
            This function has at least 7 decimals of accuracy.
            </summary>
        </member>
        <member name="P:FixMath.NET.Fix64.RawValue">
            <summary>
            The underlying integer representation
            </summary>
        </member>
        <member name="M:FixMath.NET.Fix64.#ctor(System.Int64)">
            <summary>
            This is the constructor from raw value; it can only be used interally.
            </summary>
            <param name="rawValue"></param>
        </member>
        <member name="M:SharpSteer2.Database.IProximityDatabase`1.AllocateToken(`0)">
            <summary>
            allocate a token to represent a given client object in this database
            </summary>
            <param name="parentObject"></param>
            <returns></returns>
        </member>
        <member name="P:SharpSteer2.Database.IProximityDatabase`1.Count">
            <summary>
            returns the number of tokens in the proximity database
            </summary>
        </member>
        <member name="M:SharpSteer2.Database.ITokenForProximityDatabase`1.UpdateForNewPosition(HeroBattle.FixedMath.Vector3f)">
            <summary>
            the client object calls this each time its position changes
            </summary>
            <param name="position"></param>
        </member>
        <member name="M:SharpSteer2.Database.ITokenForProximityDatabase`1.FindNeighbors(HeroBattle.FixedMath.Vector3f,System.Single,System.Collections.Generic.List{`0})">
            <summary>
            find all neighbors within the given sphere (as center and radius)
            </summary>
            <param name="center"></param>
            <param name="radius"></param>
            <param name="results"></param>
        </member>
        <member name="T:SharpSteer2.Database.LocalityQueryDatabase">
            <summary>
            This structure represents the spatial database.  Typically one of
            these would be created, by a call to lqCreateDatabase, for a given
            application.
            </summary>
        </member>
        <member name="T:SharpSteer2.Database.LocalityQueryDatabase.ClientProxy">
            <summary>
            This structure is a proxy for (and contains a pointer to) a client
            (application) obj in the spatial database.  One of these exists
            for each client obj.  This might be included within the
            structure of a client obj, or could be allocated separately.
            </summary>
        </member>
        <member name="M:SharpSteer2.Database.LocalityQueryDatabase.TraverseBinClientObjectList(SharpSteer2.Database.LocalityQueryDatabase.ClientProxy,System.Single,SharpSteer2.Database.LocalityQueryDatabase.LQCallBackFunction,System.Object,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Given a bin's list of client proxies, traverse the list and invoke
            the given lqCallBackFunction on each obj that falls within the
            search radius.
            </summary>
            <param name="co"></param>
            <param name="radiusSquared"></param>
            <param name="func"></param>
            <param name="state"></param>
            <param name="position"></param>
        </member>
        <member name="M:SharpSteer2.Database.LocalityQueryDatabase.MapOverAllObjectsInLocalityClipped(HeroBattle.FixedMath.Vector3f,System.Single,SharpSteer2.Database.LocalityQueryDatabase.LQCallBackFunction,System.Object,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This subroutine of lqMapOverAllObjectsInLocality efficiently
            traverses of subset of bins specified by max and min bin
            coordinates.
            </summary>
            <param name="center"></param>
            <param name="radius"></param>
            <param name="func"></param>
            <param name="clientQueryState"></param>
            <param name="minBinX"></param>
            <param name="minBinY"></param>
            <param name="minBinZ"></param>
            <param name="maxBinX"></param>
            <param name="maxBinY"></param>
            <param name="maxBinZ"></param>
        </member>
        <member name="M:SharpSteer2.Database.LocalityQueryDatabase.MapOverAllOutsideObjects(HeroBattle.FixedMath.Vector3f,System.Single,SharpSteer2.Database.LocalityQueryDatabase.LQCallBackFunction,System.Object)">
            <summary>
            If the query region (sphere) extends outside of the "super-brick"
            we need to check for objects in the catch-all "other" bin which
            holds any object which are not inside the regular sub-bricks
            </summary>
            <param name="center"></param>
            <param name="radius"></param>
            <param name="func"></param>
            <param name="clientQueryState"></param>
        </member>
        <member name="T:SharpSteer2.Database.LocalityQueryProximityDatabase`1">
            <summary>
            A AbstractProximityDatabase-style wrapper for the LQ bin lattice system
            </summary>
        </member>
        <member name="T:SharpSteer2.Database.LocalityQueryProximityDatabase`1.TokenType">
            <summary>
            "token" to represent objects stored in the database
            </summary>
        </member>
        <member name="M:SharpSteer2.Helpers.LocalSpaceBasisHelpers.LocalizeDirection(SharpSteer2.ILocalSpaceBasis,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Transforms a direction in global space to its equivalent in local space.
            </summary>
            <param name="basis">The basis which this should operate on</param>
            <param name="globalDirection">The global space direction to transform.</param>
            <returns>The global space direction transformed to local space .</returns>
        </member>
        <member name="M:SharpSteer2.Helpers.LocalSpaceBasisHelpers.LocalizePosition(SharpSteer2.ILocalSpaceBasis,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Transforms a point in global space to its equivalent in local space.
            </summary>
            <param name="basis">The basis which this should operate on</param>
            <param name="globalPosition">The global space position to transform.</param>
            <returns>The global space position transformed to local space.</returns>
        </member>
        <member name="M:SharpSteer2.Helpers.LocalSpaceBasisHelpers.GlobalizePosition(SharpSteer2.ILocalSpaceBasis,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Transforms a point in local space to its equivalent in global space.
            </summary>
            <param name="basis">The basis which this should operate on</param>
            <param name="localPosition">The local space position to tranform.</param>
            <returns>The local space position transformed to global space.</returns>
        </member>
        <member name="M:SharpSteer2.Helpers.LocalSpaceBasisHelpers.GlobalizeDirection(SharpSteer2.ILocalSpaceBasis,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Transforms a direction in local space to its equivalent in global space.
            </summary>
            <param name="basis">The basis which this should operate on</param>
            <param name="localDirection">The local space direction to tranform.</param>
            <returns>The local space direction transformed to global space</returns>
        </member>
        <member name="M:SharpSteer2.Helpers.LocalSpaceBasisHelpers.LocalRotateForwardToSide(SharpSteer2.ILocalSpaceBasis,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Rotates, in the canonical direction, a vector pointing in the
            "forward" (+Z) direction to the "side" (+/-X) direction as implied
            by IsRightHanded.
            </summary>
            <param name="basis">The basis which this should operate on</param>
            <param name="value">The local space vector.</param>
            <returns>The rotated vector.</returns>
        </member>
        <member name="M:SharpSteer2.Helpers.LocalSpaceBasisHelpers.SetUnitSideFromForwardAndUp(HeroBattle.FixedMath.Vector3f@,HeroBattle.FixedMath.Vector3f@,HeroBattle.FixedMath.Vector3f@)">
            <summary>
            set "side" basis vector to normalized cross product of forward and up
            </summary>
            <param name="forward"></param>
            <param name="side"></param>
            <param name="up"></param>
        </member>
        <member name="M:SharpSteer2.Helpers.LocalSpaceBasisHelpers.RegenerateOrthonormalBasisUF(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f@,HeroBattle.FixedMath.Vector3f@,HeroBattle.FixedMath.Vector3f@)">
            <summary>
            regenerate the orthonormal basis vectors given a new forward
            (which is expected to have unit length)
            </summary>
            <param name="newUnitForward"></param>
            <param name="forward"></param>
            <param name="side"></param>
            <param name="up"></param>
        </member>
        <member name="M:SharpSteer2.Helpers.LocalSpaceBasisHelpers.RegenerateOrthonormalBasis(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f@,HeroBattle.FixedMath.Vector3f@,HeroBattle.FixedMath.Vector3f@)">
            <summary>
            for when the new forward is NOT know to have unit length
            </summary>
            <param name="newForward"></param>
            <param name="forward"></param>
            <param name="side"></param>
            <param name="up"></param>
        </member>
        <member name="M:SharpSteer2.Helpers.LocalSpaceBasisHelpers.RegenerateOrthonormalBasis(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f@,HeroBattle.FixedMath.Vector3f@,HeroBattle.FixedMath.Vector3f@)">
            <summary>
            for supplying both a new forward and and new up
            </summary>
            <param name="newForward"></param>
            <param name="newUp"></param>
            <param name="forward"></param>
            <param name="side"></param>
            <param name="up"></param>
        </member>
        <member name="M:SharpSteer2.Helpers.PathwayHelpers.IsInsidePath(SharpSteer2.Pathway.IPathway,HeroBattle.FixedMath.Vector3f)">
            <summary>
            is the given point inside the path tube?
            </summary>
            <param name="pathway"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.PathwayHelpers.HowFarOutsidePath(SharpSteer2.Pathway.IPathway,HeroBattle.FixedMath.Vector3f)">
            <summary>
            how far outside path tube is the given point?  (negative is inside)
            </summary>
            <param name="pathway"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.RandomHelpers.Random">
            <summary>
            Returns a float randomly distributed between 0 and 1
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.RandomHelpers.Random(System.Single,System.Single)">
            <summary>
            Returns a float randomly distributed between lowerBound and upperBound
            </summary>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Utilities.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Linearly interpolate from A to B by amount T
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Utilities.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamp value between min and max
            </summary>
            <param name="value"></param>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Utilities.RemapInterval(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            remap a value specified relative to a pair of bounding values to the corresponding value relative to another pair of bounds.
            </summary>
            <remarks>Inspired by (dyna:remap-interval y y0 y1 z0 z1)</remarks>
            <param name="x">A value</param>
            <param name="in0">Starting lower bound</param>
            <param name="in1">Starting upper bound</param>
            <param name="out0">Ending lower bound</param>
            <param name="out1">Ending upper bound</param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Utilities.RemapIntervalClip(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Like remapInterval but the result is clipped to remain between out0 and out1
            </summary>
            <param name="x">A value</param>
            <param name="in0">Starting lower bound</param>
            <param name="in1">Starting upper bound</param>
            <param name="out0">Ending lower bound</param>
            <param name="out1">Ending upper bound</param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Utilities.IntervalComparison(System.Single,System.Single,System.Single)">
            <summary>
            classify a value relative to the interval between two bounds:
            returns -1 when below the lower bound, returns  0 when between the bounds (inside the interval), returns +1 when above the upper bound
            </summary>
            <param name="x"></param>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Utilities.BlendIntoAccumulator(System.Single,System.Single,System.Single@)">
            <summary>
            blends new values into an accumulator to produce a smoothed time series
            </summary>
            <remarks>
            Modifies its third argument, a reference to the float accumulator holding
            the "smoothed time series."
            
            The first argument (smoothRate) is typically made proportional to "dt" the
            simulation time step.  If smoothRate is 0 the accumulator will not change,
            if smoothRate is 1 the accumulator will be set to the new value with no
            smoothing.  Useful values are "near zero".
            </remarks>
            <param name="smoothRate"></param>
            <param name="newValue"></param>
            <param name="smoothedAccumulator"></param>
            <example>blendIntoAccumulator (dt * 0.4f, currentFPS, smoothedFPS)</example>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.ParallelComponent(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f)">
            <summary>
            return component of vector parallel to a unit basis vector
            </summary>
            <param name="vector"></param>
            <param name="unitBasis">A unit length basis vector</param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.PerpendicularComponent(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f)">
            <summary>
            return component of vector perpendicular to a unit basis vector
            </summary>
            <param name="vector"></param>
            <param name="unitBasis">A unit length basis vector</param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.TruncateLength(HeroBattle.FixedMath.Vector3f,System.Single)">
            <summary>
            clamps the length of a given vector to maxLength.  If the vector is
            shorter its value is returned unaltered, if the vector is longer
            the value returned has length of maxLength and is parallel to the
            original input.
            </summary>
            <param name="vector"></param>
            <param name="maxLength"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.RotateAboutGlobalY(HeroBattle.FixedMath.Vector3f,System.Single)">
            <summary>
            rotate this vector about the global Y (up) axis by the given angle
            </summary>
            <param name="vector"></param>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.RotateAboutGlobalY(HeroBattle.FixedMath.Vector3f,System.Single,System.Single@,System.Single@)">
            <summary>
            Rotate this vector about the global Y (up) axis by the given angle
            </summary>
            <param name="vector"></param>
            <param name="radians"></param>
            <param name="sin">Either Sin(radians) or default(float), if default(float) this value will be initialized with Sin(radians)</param>
            <param name="cos">Either Cos(radians) or default(float), if default(float) this value will be initialized with Cos(radians)</param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.SphericalWrapAround(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Single)">
            <summary>
            Wrap a position around so it is always within 1 radius of the sphere (keeps repeating wrapping until position is within sphere)
            </summary>
            <param name="vector"></param>
            <param name="center"></param>
            <param name="radius"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.RandomVectorOnUnitRadiusXZDisk">
            <summary>
            Returns a position randomly distributed on a disk of unit radius
            on the XZ (Y=0) plane, centered at the origin.  Orientation will be
            random and length will range between 0 and 1
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.RandomVectorInUnitRadiusSphere">
            <summary>
            Returns a position randomly distributed inside a sphere of unit radius
            centered at the origin.  Orientation will be random and length will range
            between 0 and 1
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.RandomUnitVector">
            <summary>
            Returns a position randomly distributed on the surface of a sphere
            of unit radius centered at the origin.  Orientation will be random
            and length will be 1
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.RandomUnitVectorOnXZPlane">
            <summary>
            Returns a position randomly distributed on a circle of unit radius
            on the XZ (Y=0) plane, centered at the origin.  Orientation will be
            random and length will be 1
            </summary>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.LimitMaxDeviationAngle(HeroBattle.FixedMath.Vector3f,System.Single,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Clip a vector to be within the given cone
            </summary>
            <param name="source">A vector to clip</param>
            <param name="cosineOfConeAngle">The cosine of the cone angle</param>
            <param name="basis">The vector along the middle of the cone</param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.LimitMinDeviationAngle(HeroBattle.FixedMath.Vector3f,System.Single,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Clip a vector to be outside the given cone
            </summary>
            <param name="source">A vector to clip</param>
            <param name="cosineOfConeAngle">The cosine of the cone angle</param>
            <param name="basis">The vector along the middle of the cone</param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.LimitDeviationAngleUtility(System.Boolean,HeroBattle.FixedMath.Vector3f,System.Single,HeroBattle.FixedMath.Vector3f)">
            <summary>
            used by limitMaxDeviationAngle / limitMinDeviationAngle
            </summary>
            <param name="insideOrOutside"></param>
            <param name="source"></param>
            <param name="cosineOfConeAngle"></param>
            <param name="basis"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.DistanceFromLine(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Returns the distance between a point and a line.
            </summary>
            <param name="point">The point to measure distance to</param>
            <param name="lineOrigin">A point on the line</param>
            <param name="lineUnitTangent">A UNIT vector parallel to the line</param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.Vector3fHelpers.FindPerpendicularIn3d(HeroBattle.FixedMath.Vector3f)">
            <summary>
            Find any arbitrary vector which is perpendicular to the given vector
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.VehicleHelpers.SteerToAvoidObstacle(SharpSteer2.IVehicle,System.Single,SharpSteer2.Obstacles.IObstacle,SharpSteer2.IAnnotationService)">
            <summary>
            Returns a steering force to avoid a given obstacle.  The purely
            lateral steering force will turn our this towards a silhouette edge
            of the obstacle.  Avoidance is required when (1) the obstacle
            intersects the this's current path, (2) it is in front of the
            this, and (3) is within minTimeToCollision seconds of travel at the
            this's current velocity.  Returns a zero vector value (Vector3f::zero)
            when no avoidance is required.
            </summary>
            <param name="vehicle"></param>
            <param name="minTimeToCollision"></param>
            <param name="obstacle"></param>
            <param name="annotation"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.VehicleHelpers.SteerToAvoidCloseNeighbors``1(SharpSteer2.IVehicle,System.Single,System.Collections.Generic.IEnumerable{``0},SharpSteer2.IAnnotationService)">
            <summary>
            avoidance of "close neighbors"
            </summary>
            <remarks>
            Does a hard steer away from any other agent who comes withing a
            critical distance.  Ideally this should be replaced with a call
            to steerForSeparation.
            </remarks>
            <typeparam name="TVehicle"></typeparam>
            <param name="vehicle"></param>
            <param name="minSeparationDistance"></param>
            <param name="others"></param>
            <param name="annotation"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.VehicleHelpers.SteerForTargetSpeed(SharpSteer2.IVehicle,System.Single,System.Single,SharpSteer2.IAnnotationService)">
            <summary>
            tries to maintain a given speed, returns a maxForce-clipped steering
            force along the forward/backward axis
            </summary>
            <param name="vehicle"></param>
            <param name="targetSpeed"></param>
            <param name="maxForce"></param>
            <param name="annotation"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.VehicleHelpers.SteerToAvoidNeighbors(SharpSteer2.IVehicle,System.Single,System.Collections.Generic.IEnumerable{SharpSteer2.IVehicle},SharpSteer2.IAnnotationService)">
            <summary>
            Unaligned collision avoidance behavior: avoid colliding with other
            nearby vehicles moving in unconstrained directions.  Determine which
            (if any) other other this we would collide with first, then steers
            to avoid the site of that potential collision.  Returns a steering
            force vector, which is zero length if there is no impending collision.
            </summary>
            <param name="vehicle"></param>
            <param name="minTimeToCollision"></param>
            <param name="others"></param>
            <param name="annotation"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.VehicleHelpers.PredictNearestApproachTime(SharpSteer2.IVehicle,SharpSteer2.IVehicle)">
            <summary>
            Given two vehicles, based on their current positions and velocities,
            determine the time until nearest approach
            </summary>
            <param name="vehicle"></param>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Helpers.VehicleHelpers.ComputeNearestApproachPositions(SharpSteer2.IVehicle,SharpSteer2.IVehicle,System.Single)">
            <summary>
            Given the time until nearest approach (predictNearestApproachTime)
            determine position of each this at that time, and the distance
            between them
            </summary>
            <param name="vehicle"></param>
            <param name="other"></param>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:SharpSteer2.IAnnotationService">
            <summary>
            Provides methods to annotate the steering behaviors.
            </summary>
        </member>
        <member name="P:SharpSteer2.IAnnotationService.IsEnabled">
            <summary>
            Indicates whether annotation is enabled.
            </summary>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.Line(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Single)">
            <summary>
            Draws an opaque colored line segment between two locations in space.
            </summary>
            <param name="startPoint">The start point of the line.</param>
            <param name="endPoint">The end point of the line.</param>
            <param name="color">The color of the line.</param>
            <param name="opacity"></param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.CircleXZ(System.Single,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Int32)">
            <summary>
            Draws a circle on the XZ plane.
            </summary>
            <param name="radius">The radius of the circle.</param>
            <param name="center">The center of the circle.</param>
            <param name="color">The color of the circle.</param>
            <param name="segments">The number of segments to use to draw the circle.</param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.DiskXZ(System.Single,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Int32)">
            <summary>
            Draws a disk on the XZ plane.
            </summary>
            <param name="radius">The radius of the disk.</param>
            <param name="center">The center of the disk.</param>
            <param name="color">The color of the disk.</param>
            <param name="segments">The number of segments to use to draw the disk.</param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.Circle3D(System.Single,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Int32)">
            <summary>
            Draws a circle perpendicular to the given axis.
            </summary>
            <param name="radius">The radius of the circle.</param>
            <param name="center">The center of the circle.</param>
            <param name="axis">The axis of the circle.</param>
            <param name="color">The color of the circle.</param>
            <param name="segments">The number of segments to use to draw the circle.</param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.Disk3D(System.Single,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Int32)">
            <summary>
            Draws a disk perpendicular to the given axis.
            </summary>
            <param name="radius">The radius of the disk.</param>
            <param name="center">The center of the disk.</param>
            <param name="axis">The axis of the disk.</param>
            <param name="color">The color of the disk.</param>
            <param name="segments">The number of segments to use to draw the disk.</param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.CircleOrDiskXZ(System.Single,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Int32,System.Boolean)">
            <summary>
            Draws a circle (not filled) or disk (filled) on the XZ plane.
            </summary>
            <param name="radius">The radius of the circle/disk.</param>
            <param name="center">The center of the circle/disk.</param>
            <param name="color">The color of the circle/disk.</param>
            <param name="segments">The number of segments to use to draw the circle/disk.</param>
            <param name="filled">Flag indicating whether to draw a disk or circle.</param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.CircleOrDisk3D(System.Single,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Int32,System.Boolean)">
            <summary>
            Draws a circle (not filled) or disk (filled) perpendicular to the given axis.
            </summary>
            <param name="radius">The radius of the circle/disk.</param>
            <param name="center">The center of the circle/disk.</param>
            <param name="axis">The axis of the circle/disk.</param>
            <param name="color">The color of the circle/disk.</param>
            <param name="segments">The number of segments to use to draw the circle/disk.</param>
            <param name="filled">Flag indicating whether to draw a disk or circle.</param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.CircleOrDisk(System.Single,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Draws a circle (not filled) or disk (filled) perpendicular to the given axis.
            </summary>
            <param name="radius">The radius of the circle/disk.</param>
            <param name="axis">The axis of the circle/disk.</param>
            <param name="center">The center of the circle/disk.</param>
            <param name="color">The color of the circle/disk.</param>
            <param name="segments">The number of segments to use to draw the circle/disk.</param>
            <param name="filled">Flag indicating whether to draw a disk or circle.</param>
            <param name="in3D">Flag indicating whether to draw the disk/circle in 3D or the XZ plane.</param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.AvoidObstacle(System.Single)">
            <summary>
            Called when steerToAvoidObstacles decides steering is required.
            </summary>
            <param name="minDistanceToCollision"></param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.PathFollowing(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f,System.Single)">
            <summary>
            Called when steerToFollowPath decides steering is required.
            </summary>
            <param name="future"></param>
            <param name="onPath"></param>
            <param name="target"></param>
            <param name="outside"></param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.AvoidCloseNeighbor(SharpSteer2.IVehicle,System.Single)">
            <summary>
            Called when steerToAvoidCloseNeighbors decides steering is required.
            </summary>
            <param name="other"></param>
            <param name="additionalDistance"></param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.AvoidNeighbor(SharpSteer2.IVehicle,System.Single,HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f)">
            <summary>
            Called when steerToAvoidNeighbors decides steering is required.
            </summary>
            <param name="threat"></param>
            <param name="steer"></param>
            <param name="ourFuture"></param>
            <param name="threatFuture"></param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.VelocityAcceleration(SharpSteer2.IVehicle)">
            <summary>
            Draws lines from the vehicle's position showing its velocity and acceleration.
            </summary>
            <param name="vehicle">The vehicle to annotate.</param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.VelocityAcceleration(SharpSteer2.IVehicle,System.Single)">
            <summary>
            Draws lines from the vehicle's position showing its velocity and acceleration.
            </summary>
            <param name="vehicle">The vehicle to annotate.</param>
            <param name="maxLength">The maximum length for the acceleration and velocity lines.</param>
        </member>
        <member name="M:SharpSteer2.IAnnotationService.VelocityAcceleration(SharpSteer2.IVehicle,System.Single,System.Single)">
            <summary>
            Draws lines from the vehicle's position showing its velocity and acceleration.
            </summary>
            <param name="vehicle">The vehicle to annotate.</param>
            <param name="maxLengthAcceleration">The maximum length for the acceleration line.</param>
            <param name="maxLengthVelocity">The maximum length for the velocity line.</param>
        </member>
        <member name="T:SharpSteer2.IFlowField">
            <summary>
            A flow field which can be sampled at arbitrary locations
            </summary>
        </member>
        <member name="M:SharpSteer2.IFlowField.Sample(HeroBattle.FixedMath.Vector3f)">
            <summary>
            Sample the flow field at the given location
            </summary>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="T:SharpSteer2.ILocalSpaceBasis">
            <summary>
            transformation as three orthonormal unit basis vectors and the
            origin of the local space.  These correspond to the "rows" of
            a 3x4 transformation matrix with [0 0 0 1] as the final column
            </summary>
        </member>
        <member name="P:SharpSteer2.ILocalSpaceBasis.Side">
            <summary>
            side-pointing unit basis vector
            </summary>
        </member>
        <member name="P:SharpSteer2.ILocalSpaceBasis.Up">
            <summary>
            upward-pointing unit basis vector
            </summary>
        </member>
        <member name="P:SharpSteer2.ILocalSpaceBasis.Forward">
            <summary>
            forward-pointing unit basis vector
            </summary>
        </member>
        <member name="P:SharpSteer2.ILocalSpaceBasis.Position">
            <summary>
            origin of local space
            </summary>
        </member>
        <member name="P:SharpSteer2.IVehicle.Mass">
            <summary>
            mass (defaults to unity so acceleration=force)
            </summary>
        </member>
        <member name="P:SharpSteer2.IVehicle.Radius">
            <summary>
            size of bounding sphere, for obstacle avoidance, etc.
            </summary>
        </member>
        <member name="P:SharpSteer2.IVehicle.Velocity">
            <summary>
            velocity of vehicle
            </summary>
        </member>
        <member name="P:SharpSteer2.IVehicle.Acceleration">
            <summary>
            Gets the acceleration of the vehicle.
            </summary>
        </member>
        <member name="P:SharpSteer2.IVehicle.Speed">
            <summary>
            speed of vehicle (may be faster than taking magnitude of velocity)
            </summary>
        </member>
        <member name="M:SharpSteer2.IVehicle.PredictFuturePosition(System.Single)">
            <summary>
            predict position of this vehicle at some time in the future (assumes velocity remains constant)
            </summary>
            <param name="predictionTime"></param>
            <returns></returns>
        </member>
        <member name="P:SharpSteer2.IVehicle.MaxForce">
            <summary>
            the maximum steering force this vehicle can apply
            </summary>
        </member>
        <member name="P:SharpSteer2.IVehicle.MaxSpeed">
            <summary>
            the maximum speed this vehicle is allowed to move
            </summary>
        </member>
        <member name="T:SharpSteer2.LocalSpaceBasis">
            <summary>
            transformation as three orthonormal unit basis vectors and the
            origin of the local space.  These correspond to the "rows" of
            a 3x4 transformation matrix with [0 0 0 1] as the final column
            </summary>
        </member>
        <member name="P:SharpSteer2.LocalSpaceBasis.Side">
            <summary>
            side-pointing unit basis vector
            </summary>
        </member>
        <member name="P:SharpSteer2.LocalSpaceBasis.Up">
            <summary>
            upward-pointing unit basis vector
            </summary>
        </member>
        <member name="P:SharpSteer2.LocalSpaceBasis.Forward">
            <summary>
            forward-pointing unit basis vector
            </summary>
        </member>
        <member name="P:SharpSteer2.LocalSpaceBasis.Position">
            <summary>
            origin of local space
            </summary>
        </member>
        <member name="T:SharpSteer2.LocalSpace">
            <summary>
            LocalSpaceMixin is a mixin layer, a class template with a paramterized base
            class.  Allows "LocalSpace-ness" to be layered on any class.
            </summary>
        </member>
        <member name="T:SharpSteer2.Obstacles.IObstacle">
            <summary>
            Obstacle: a pure virtual base class for an abstract shape in space, to be
            used with obstacle avoidance.
            </summary>
        </member>
        <member name="T:SharpSteer2.Obstacles.SphericalObstacle">
            <summary>
            SphericalObstacle a simple concrete type of obstacle.
            </summary>
        </member>
        <member name="M:SharpSteer2.Obstacles.SphericalObstacle.SteerToAvoid(SharpSteer2.IVehicle,System.Single)">
             <summary>
             Checks for intersection of the given spherical obstacle with a
             volume of "likely future vehicle positions": a cylinder along the
             current path, extending minTimeToCollision seconds along the
             forward axis from current position.
            
             If they intersect, a collision is imminent and this function returns
             a steering force pointing laterally away from the obstacle's center.
            
             Returns a zero vector if the obstacle is outside the cylinder
             </summary>
             <param name="v"></param>
             <param name="minTimeToCollision"></param>
             <returns></returns>
        </member>
        <member name="T:SharpSteer2.Pathway.GatewayPathway">
            <summary>
            A path consisting of a series of gates which must be passed through
            </summary>
        </member>
        <member name="M:SharpSteer2.Pathway.IPathway.MapPointToPath(HeroBattle.FixedMath.Vector3f,HeroBattle.FixedMath.Vector3f@,System.Single@)">
            <summary>
            Given an arbitrary point ("A"), returns the nearest point ("P") on
            this path.  Also returns, via output arguments, the path tangent at
            P and a measure of how far A is outside the Pathway's "tube".  Note
            that a negative distance indicates A is inside the Pathway.
            </summary>
            <param name="point"></param>
            <param name="tangent"></param>
            <param name="outside"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Pathway.IPathway.MapPathDistanceToPoint(System.Single)">
            <summary>
            given a distance along the path, convert it to a point on the path
            </summary>
            <param name="pathDistance"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.Pathway.IPathway.MapPointToPathDistance(HeroBattle.FixedMath.Vector3f)">
            <summary>
            Given an arbitrary point, convert it to a distance along the path.
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="T:SharpSteer2.Pathway.PolylinePathway">
            <summary>
            PolylinePathway: a simple implementation of the Pathway protocol.  The path
            is a "polyline" a series of line segments between specified points.  A
            radius defines a volume for the path which is the union of a sphere at each
            point and a cylinder along each segment.
            </summary>
        </member>
        <member name="M:SharpSteer2.Pathway.PolylinePathway.#ctor(System.Collections.Generic.IList{HeroBattle.FixedMath.Vector3f},System.Single,System.Boolean)">
            <summary>
            construct a PolylinePathway given the number of points (vertices),
            an array of points, and a path radius.
            </summary>
            <param name="points"></param>
            <param name="radius"></param>
            <param name="cyclic"></param>
        </member>
        <member name="T:SharpSteer2.Pathway.TrianglePathway">
            <summary>
            A pathway made out of triangular segments
            </summary>
        </member>
        <member name="M:SharpSteer2.SimpleVehicle.AdjustRawSteeringForce(HeroBattle.FixedMath.Vector3f,System.Single)">
            <summary>
            adjust the steering force passed to applySteeringForce.
            allows a specific vehicle class to redefine this adjustment.
            default is to disallow backward-facing steering at low speed.
            </summary>
            <param name="force"></param>
            <param name="deltaTime"></param>
            <returns></returns>
        </member>
        <member name="M:SharpSteer2.SimpleVehicle.ApplyBrakingForce(System.Single,System.Single)">
            <summary>
            apply a given braking force (for a given dt) to our momentum.
            </summary>
            <param name="rate"></param>
            <param name="deltaTime"></param>
        </member>
        <member name="M:SharpSteer2.SimpleVehicle.PredictFuturePosition(System.Single)">
            <summary>
            predict position of this vehicle at some time in the future (assumes velocity remains constant)
            </summary>
            <param name="predictionTime"></param>
            <returns></returns>
        </member>
    </members>
</doc>
